╔═══════════════════════════════════════════════════════════════╗
║                                                               ║
║          ASSISTANT PERSONNEL - SYNTHÈSE DU PROJET             ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝

╔══════════════════════════════╗
║         GÉNÉRALITÉS          ║
╚══════════════════════════════╝

▪ Objectif : Assistant personnel boosté par IA pour améliorer la vie dans tous les domaines via architecture modulaire et universelle
▪ Hardware : Sony Xperia XZ2 Compact + LineageOS - appareil 100% dédié sans distractions, objet personnel distinct du smartphone.
▪ Usage : Assistant actif + suivi poussé, mix d'interactions selon moments (check rapide, sessions intenses, sollicitations proactives).
▪ Timeline : 6 mois pour version fonctionnelle complète.
▪ Usage personnel prioritaire (distribution publique plus tard)
▪ Structure robuste dès le départ
▪ Technologie : Android natif (Kotlin + Compose) pour contrôle graphique total

═══ Collaboration IA - Humain ═══
▪ Symétrie fonctionnelle : Capacités identiques d'actions Humain / IA via commandes bidirectionnelles (depuis IA via interface de commandes ou depuis interface graphique)
▪ L'IA facilite certaines actions qui seraient manuellement lourdes (configuration des outils, intégration de données, etc.) et apporte son intelligence pour enrichir les données

═══ Flexibilité et évolutivité ═══
▪ Zones et outils sont personnalisés et organisés par l'utilisateur
▪ Zones et outils s'affinent avec l'usage


╔══════════════════════════════╗
║     MODULARITÉ DU CODE       ║
╚══════════════════════════════╝

═══ Internationalisation ═══
▪ Système Android natif `strings.xml` - ajouter une langue = ajouter des fichiers dans le projet
▪ Structure standardisée pour toutes les langues
▪ 1 fichier de langue core + 1 fichier par outil

═══ Modularité des outils ═══
▪ Structure physique : 1 outil = 1 dossier avec organisation interne standardisée
▪ Architecture logique : système d'interfaces/contrats pour garantir les éléments communs obligatoires (métadonnées JSON, structure config JSON, page config, comportement clic, etc.) tout en laissant liberté d'implémentation


╔══════════════════════════════╗
║       FONCTIONNALITÉS        ║
╚══════════════════════════════╝

═══ Zones ═══
Thèmes plus ou moins larges (Alimentation, Santé, Productivité, Rêves lucides, Auto-observation/métacognition, etc.) qui jouent le rôle de catégories pour rassembler des outils.


═══ Outils ═══
Fonctionnalités ciblées - dont le type peut être :

── Suivi ──
Saisie et historique de données temporelles quantitatives ou qualitatives

── Objectif ──
Système de critères de réussite avec poids relatifs pour sous-objectifs + items (3 niveaux de poids), et seuil de réussite paramétrable. Validation obligatoire avant finalisation pour confirmer le statut final (succès/échec) et éviter les oublis. Structure arborescente simple sans logique de dépendance.

── Calcul ──
Opérations mathématiques sur des données (réalisé par l'app)

── Statistique ──
Corrélations et analyses de données (réalisé par l'app)

── Graphique ──
Visualisations basées sur données de suivi, de calcul, de statistiques ou autres données compatibles

── Liste ──
Items à cocher

── Journal ──
Entrées textuelles/audio libres avec dates

── Note ──
Titre et texte/audio

── Message ──
Notifications et rappels (= messages planifiés, conçus par l'utilisateur ex: rappel de rdv, ou par l'IA ex: citation inspirante quotidienne)

── Alerte ──
Déclenchement automatique sur valeurs limites (= messages non planifiés à déclenchement auto par l'app)

── Actions auto ──
Automatisations programmées (calculs, statistique, analyse IA etc)


╔══════════════════════════════╗
║   NAVIGATION ET ÉCRANS       ║
╚══════════════════════════════╝

═══ Les différents écrans ═══

── Écran Principal ──
▪ Accès aux zones : Boutons/tuiles vers les différentes zones
▪ Terminal : feedback en arrière-plan (calculs, échanges IA, etc.)

── Zones ──
▪ Outils associés à cette zone (suivis, objectifs, journaux, etc.)

── Ecrans par type d'outil ──
▪ Graphiques, Objectifs, Journaux, Messages, etc.
▪ Regroupent les informations par type d'outil plutôt que par zone

── Interface IA ──
▪ Chat unifié accessible depuis n'importe quel écran (bouton toggle)
▪ Enrichissements contextuels selon écran de lancement
▪ Historique des sessions et états en temps réel


╔══════════════════════════════╗
║             IA               ║
╚══════════════════════════════╝

═══ Principe général ═══
▪ Interface de chat unifiée avec enrichissements intégrés
▪ Communication exclusivement via commandes JSON structurées (pas d'accès direct aux données)
▪ Navigation par métadonnées puis accès aux données spécifiques selon besoins
▪ Intégration complète avec le Coordinateur (`initiated_by: "ai"`)

═══ Enrichissements conversationnels ═══
▪ 6 catégories d'actions : 🔍 Données, 📝 Utiliser, ✨ Créer, 🔧 Modifier, 📁 Organiser, 📚 Documenter
▪ Configuration via overlays → blocs intégrés dans message
▪ L'IA comprend le contexte par ordre séquentiel des enrichissements
▪ Workflow naturel : écrire → enrichir → envoyer

═══ Sessions et validation ═══
▪ Sessions persistantes jusqu'à terminaison explicite utilisateur
▪ Actions validées en temps réel via modules de communication dans conversation
▪ Historique chronologique des actions IA ↔ Utilisateur
▪ Pas de file d'attente d'actions, tout traité immédiatement

═══ Architecture technique ═══
▪ PromptManager : assemblage dynamique de fragments selon contexte
▪ Modules de communication standardisés (MultipleChoice, Slider, etc.)
▪ Système de permissions granulaires par cascade (app -> zone -> type d'outil -> instance d'outil)
▪ Gestion offline : requêtes en attente de connexion avec retry automatique (détail à préciser)

═══ Documentation détaillée ═══
▪ Voir documentation/AI/


╔══════════════════════════════╗
║     GESTION DES DONNÉES      ║
╚══════════════════════════════╝

▪ Données = mémoire partagée entre App, IA et Humain

═══ Base auto-descriptive ═══

── Schémas JSON ──
▪ Validation et description des données via schémas JSON standards
▪ Permet navigation par IA sans avoir besoin d'accéder aux données elles-mêmes

── Event sourcing ──
▪ Toutes modifications passent par événements
▪ Logging des modifications
▪ Evite synchronisation manuelle

═══ Verbalisation ═══
▪ Système de verbalisation des actions de modification, des états de l'app, de divers résultats
▪ Configuré par templates au niveau core + outils
▪ Ex : "[source] [verb] le titre [old_value] en [new_value]" -> L'ia a modifié le titre Blup en Blip
▪ Utilisé pour historique, validation utilisateur des propositions IA, etc.
▪ Action verbalisable = action archivable
