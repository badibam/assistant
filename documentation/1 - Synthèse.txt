╔═══════════════════════════════════════════════════════════════╗
║                                                               ║
║          ASSISTANT PERSONNEL - SYNTHÈSE DU PROJET             ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝

╔══════════════════════════════╗
║         GÉNÉRALITÉS          ║
╚══════════════════════════════╝

▪ Objectif : Assistant personnel boosté par IA pour améliorer la vie dans tous les domaines via architecture modulaire et universelle
▪ Hardware : Sony Xperia XZ2 Compact + LineageOS - appareil 100% dédié sans distractions, objet personnel distinct du smartphone.
▪ Usage : Assistant actif + suivi poussé, mix d'interactions selon moments (check rapide, sessions intenses, sollicitations proactives).
▪ Timeline : 6 mois pour version fonctionnelle complète.
▪ Usage personnel prioritaire (distribution publique plus tard)
▪ Structure robuste dès le départ
▪ Technologie : Android natif (Kotlin + Compose) pour contrôle graphique total

═══ Collaboration IA - Humain ═══
▪ Symétrie fonctionnelle : Capacités identiques d'actions Humain / IA via commandes bidirectionnelles (depuis IA via interface de commandes ou depuis interface graphique)
▪ L'IA facilite certaines actions qui seraient manuellement lourdes (configuration des outils, intégration de données, etc.) et apporte son intelligence pour enrichir les données

═══ Flexibilité et évolutivité ═══
▪ Zones et outils sont personnalisés et organisés par l'utilisateur
▪ Zones et outils s'affinent avec l'usage


╔══════════════════════════════╗
║     MODULARITÉ DU CODE       ║
╚══════════════════════════════╝

═══ Internationalisation ═══
▪ Système Android natif `strings.xml` - ajouter une langue = ajouter des fichiers dans le projet
▪ Structure standardisée pour toutes les langues
▪ 1 fichier de langue core + 1 fichier par outil

═══ Modularité des outils ═══
▪ Structure physique : 1 outil = 1 dossier avec organisation interne standardisée
▪ Architecture logique : système d'interfaces/contrats pour garantir les éléments communs obligatoires (métadonnées JSON, structure config JSON, page config, comportement clic, etc.) tout en laissant liberté d'implémentation
▪ Composants de base réutilisables disponibles (mais non contraints) pour la manière dont l'outil proprement dit s'affiche (le graphique, le journal, la notif, etc.)

═══ Système de thèmes graphiques ═══
▪ Structure modulaire : 1 nouveau thème = 1 nouveau dossier dans le projet
▪ Encapsulation complète des composants Android (import via `UI.*` pour clarté)
▪ Contrôle graphique total : des couleurs de base jusqu'aux détails d'interaction (sélection texte, curseurs) pour permettre des thèmes extrêmes (8-bit, pixelisé)


╔══════════════════════════════╗
║       FONCTIONNALITÉS        ║
╚══════════════════════════════╝

═══ Zones ═══
Thèmes plus ou moins larges (Alimentation, Santé, Productivité, Rêves lucides, Auto-observation/métacognition, etc.) qui jouent le rôle de catégories pour rassembler des outils.


═══ Outils ═══
Fonctionnalités ciblées - dont le type peut être :

── Suivi ──
Saisie et historique de données temporelles quantitatives ou qualitatives

── Objectif ──
Système de critères de réussite avec poids relatifs pour sous-objectifs + items (3 niveaux de poids), et seuil de réussite paramétrable. Validation obligatoire avant finalisation pour confirmer le statut final (succès/échec) et éviter les oublis. Structure arborescente simple sans logique de dépendance.

── Calcul ──
Opérations mathématiques sur des données (réalisé par l'app)

── Statistique ──
Corrélations et analyses de données (réalisé par l'app)

── Graphique ──
Visualisations basées sur données de suivi, de calcul, de statistiques ou autres données compatibles

── Liste ──
Items à cocher

── Journal ──
Entrées textuelles/audio libres avec dates

── Note ──
Titre et texte/audio

── Message ──
Notifications et rappels (= messages planifiés, conçus par l'utilisateur ex: rappel de rdv, ou par l'IA ex: citation inspirante quotidienne)

── Alerte ──
Déclenchement automatique sur valeurs limites (= messages non planifiés à déclenchement auto par l'app)

── Analyse ──
Insights et analyses générées par l'IA qui donnent lieu notamment à des Rapports

── Actions auto ──
Automatisations programmées (calculs, statistique, analyse IA etc)


╔══════════════════════════════╗
║   NAVIGATION ET ÉCRANS       ║
╚══════════════════════════════╝


═══ Généralités ═══

▪ La navigation est cohérente parmi les différents écrans : clic = accès au contenu; clic long = accès aux paramètres
▪ Différents écrans permettent d'accéder de différentes façon aux données / fonctionnalités
▪ Les outils peuvent être configurés pour être plus ou moins denses : Minimal, Condensé, Détaillé (réglages par défaut + spécifiques)
▪  Zone "Appel IA" disponible en permanence (toggle), qui indique quelques mots de contexte


═══ Les différents écrans ═══

── Écran Principal ──
▪ Accès aux zones : Boutons/tuiles vers les différentes zones
▪ Terminal : un endroit de l'écran principal dans lequel le programme indique à l'utilisateur ce qu'il est en train de faire en arrière-plan (calcul de données, échange avec l'IA, etc.)

── Zones ──
▪ Outils associés à cette zone (suivis, objectifs, journaux, etc.)

── Ecrans par type d'outil ──
▪ Graphiques, Objectifs, Journaux, Messages, etc.
▪ Regroupent les informations par type d'outil plutôt que par zone.

── File d'attente ──
▪ Liste des actions prévues par l'app (Requêtes IA, calculs, statistiques, notification, etc.)
▪ Possibilité de changer l'ordre, le moment, les instructions, etc.
▪ Liste notamment les requêtes IA en attente de réseau si offline

── Discussions ──
▪ Historique des discussions avec l'IA (résumés)


╔══════════════════════════════╗
║             IA               ║
╚══════════════════════════════╝

═══ Système de prompts ═══

── Prompt manager ──
▪ Connaît le contexte global de la session (déclencheur, type de reqûete, etc.)
▪ Connaît l'état actuel de la session
▪ Assemble en conséquence des fragments en un prompt
▪ Ensuite se laisse piloter par l'IA via l'interface de commandes
▪ Reprend la main quand l'IA ne demande plus d'infos
▪ Reprend la main par règles prédéfinies (dépassement tokens, erreur, coupure internet, etc.)

── Types de fragments ──
▪ Prompt intro de base (incluant fragment minimal de documentation d'interface de commandes)
▪ Fragments de documentation d'interface de commandes
▪ Contexte dynamique (depuis où la requête est-elle envoyée, avec quelles précisions de l'utilisateur, etc.)
▪ Descriptifs JSON (metadata) des différents objets
▪ Données elles-mêmes

── Hiérarchie des prompts ──
▪ Cascade de prompts selon le contexte
▪ Ex: session générale → outil de type suivi → outil de suivi spécifique → modification du suivi

── Economie des tokens ──
▪ Spécification systématique dans métadonnées de longueur de texte, de l'utilisation appropriée/ non appropriée
▪ Différentes versions d'une même donnée, par exemple pour journaux : entrée brute, résumé 1 paragraphe, résumé 1 phrase, résumé en quelques mots-clés


═══ Interface de commandes ═══

▪ Dialogue entre IA et App via interface de commandes JSON

── Structure ──
▪ Liste de commandes JSON
▪ Chaque commande contient : point d'accès, paramètres (JSON), description de l'action, raison, id (pour référence future dans la session), ...

── Points d'accès ──
▪ Navigation : explorer les données via les métadonnées uniquement
▪ Accès : accéder au contenu réel
▪ Modifications : modifier l'état (CRUD, configuration, calculs, etc.)
▪ Message : dialoguer avec l'utilisateur dans le contexte de cette session

── Logique de contrôle ──
▪ IA : agit selon ce qui lui semble approprié
▪ App : applique ses mécanismes de contrôle après coup
▪ Retours détaillés : succès/échec/validation_requise/permission_refusée, etc.
▪ IA reçoit les résultats si session continue


═══ Navigation des données ═══
▪ L'IA reçoit les infos de structure, interface de commandes, navigation dans méta/données
▪ L'IA demande les méta/données au fur et à mesure de ses besoins


═══ Discussions ═══
▪ Il est possible de lancer un thread de discussion avec l'IA depuis n'importe quel écran de l'app
▪ Le contexte où a été lancée la discussion sera intégré dans le prompt
▪ IA répond à l'humain et décide de lancer des actions
▪ Les actions sont présentées à l'humain pour validation (action proposée + raison ; regroupées par batch si nombreuses)
▪ Les discussions ne sont pas nécessairement conservées (sauf peut être pour amélioration de l'app)
▪ Une discussion terminée donne lieu à un résumé qui est enregistré
-----Dévelopements éventuels-----
▪ Une discussion reste "en cours" tant que l'utilisateur ne la marque pas comme terminée.


═══ Actions de l'IA ═══
▪ L'IA peut intervenir partout (CRUD, configuration, etc.)
▪ Validation : selon le contexte: validation des actions proposées par l'IA. (Actions critiques, préférence utilisateur, etc.)


═══ Gestion online/offline ═══

── Offline ──
▪ Certaines fonctionnalités restent disponibles : Suivi, Journaux, Calculs, etc.
▪ Requêtes IA mises en File d'attente

── Online ──
▪ Traitement des Requêtes en attente
▪ Interactions IA en temps réel (Discussions)


╔══════════════════════════════╗
║     GESTION DES DONNÉES      ║
╚══════════════════════════════╝

▪ Données = mémoire partagée entre App, IA et Humain

═══ Base auto-descriptive ═══

── Structure miroir data/metadata ──
▪ Tous les champs en db (+ données étendues JSON) ont leur description dans structure JSON parallèle
▪ Hiérarchie identique
▪ Descriptions générées par IA/utilisateur/système
▪ Permet navigation par IA sans avoir besoin d'accéder aux données elles-mêmes.
▪ Champs du genre "_self": {"description": "Outil de suivi du poids corporel", "source":"system"}

── Event sourcing ──
▪ Toutes modifications passent par événements
▪ Synchronisation auto de la structure data/metadata
▪ Logging des modifications
▪ Evite synchronisation manuelle

── Gestion des cascades d'actions ──
▪ Automatiques (App gère) ex: synchronisation structure data/metadata
▪ Validation (App peut gérer) ex: suppression outil → suppression données ?
▪ IA gère (Humain en théorie peut gérer) : Modifs subséquentes sur la base des modifs effectuées (cf logs, contexte, etc.)


═══ Verbalisation ═══
▪ Système de verbalisation des actions de modification, des états de l'app, de divers résultats
▪ Configuré par templates au niveau core + outils
▪ Ex : "[source] [verb] le titre [old_value] en [new_value]" -> L'ia a modifié le titre Blup en Blip
▪ Utilisé pour historique, validation utilisateur des propositions IA, etc.
▪ Action verbalisable = action archivable
